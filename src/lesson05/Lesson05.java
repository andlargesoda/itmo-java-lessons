package lesson05;

import java.util.Arrays;

public class Lesson05 {
    public static void main(String[] args) {

        // массивы - ссылочный тип
        // int - определяем тип данных переменных, которые будут хранится в массиве
        // int[] - объявляем массив
        // [] - массив в принципе
        // + - оператор присваивания
        // {} - значение массива
        int[] codes = {544, 231, 700, 533, 455};
        System.out.println(codes[3]); // 533
        System.out.println(codes[1]); // 231

        // java.lang.ArrayIndexOutOfBoundsException (ошибка времени выполнения)
        // ошибка времени выполнения - проявляются не сразу, а спустя время при работе интерпритатора
        // выход за пределы массива - ошибка, которая прерывает выполнение программы
        // System.out.println(codes[10]);

        // длина массива - кол-во элементов массива, определяется типом int >= 0
        // длина массива нельзя изменить, можно создать новый с необходимой длиной
        // используем своейство length
        System.out.println(codes.length); // 5, т.е. 5 элементом

        System.out.println(codes[codes.length-1]); // длина массива - 1 = последний элемент массива, 455

        // вывести в консоль случайный элемент массива, индекс определить, используя Math.random()
        // минимальный индекс элемента в массиве 0
        // максиимальный индекс элемента в массиве имя_массива.length-1
        // Math.random() генерируют случайное число в диапазоне [0;1)
        // если длина ммассива, например, 5 [0,...,4], то Math.random()*...lemgth даст диапазон [0;5) или [0;4]
        int number = (int)Math.random()*codes.length;
        System.out.println(codes[number]);

        // перебор массива в цикле
        // дает возможность перебрать массив раличными способами
        // от 1-го элемента к последнему, наоборот и т.д.
        // дает возможность изменять значения элементов массива
        // 1 итерация - обращение к одному элементу массива
        for (int i = 0; i < codes.length; i++) { // i - индексы элементов массива
            System.out.println(codes[i]);
            if (codes[i] < 1000) {
                codes[i] += 1000;
            }
        }

        // iter - for each, перебирает от 1 элемента до последнего и изменять элементы нельзя
        // значение элемента массива копируется в code, поэтому мы можем изменить только code,
        // но не элемент массива
        for (int code : codes) { // codes - перебираемый массив
            // int code, где int - тип элементов массива
            // code - значение элемента массива (копия для примитивов, ссылка для ссылочных типов)
            System.out.println(code);

            // объявление массива со значениями по умолчанию
            int[] ints01 = new int[10]; // создали массив с храненим чисел int и длиной 10 (10 int чисел)
            // длина массива может задаваться через переменную, число или выражение (все дб > 0)
            String[] colors = new String[4]; // создали массив с храненим строк и длиной 4 (4 строки)

            // массив со значениеями по умолчанию наполняются - ...:
            // byte, short, int, long - 0
            // float, double - 0.0
            // boolean - false
            // ссылочные типы - null

            // заменить дефолтные значения массива ints01 случайными числами в диапазоне [0;30)
            // для замены использовать цикл
            for (int i = 0; i < ints01.length; i++) {
                // на каждой итерации обращаемся к элементу массива по индексу ints01[i]
                // ints01[i] присваиваем значение через Math.random() в диапазоне [0;30), т.е.
                ints01[i] = (int)(Math.random() * 30);
                System.out.println(ints01[i]);
            }

            colors[0] = "RD";
            colors[1] = "YE";
            colors[2] = "GN";
            colors[3] = "BK";
            for (String color : colors) {
                if (color.equals("RD")) {
                    System.out.println("yes");
                    break;
                }
            }
            System.out.println(colors);

            // класс Arrays - собран функционал, который позволяет работать с массивами
            // для использования Arrays необходим import java.util.Arrays
            // должен проставляться автоматически
            // метод Arrays.toString() - печать массива в терминале
            System.out.println(Arrays.toString(colors)); // вызов статического метода, который находится в классе Arrays

            // методы для работы с массивами
            double[] temps = {45.7, 22.9, 12.0, 33.8, 98.1};
            // методы сортировки массива sort() из классе Arrays
            // если сортировка чисел, то по возрастанию
            // если сортировка строк, то по возрастанию символов Unicode (по алфавиту)
            Arrays.sort(temps); // меняет исходный массив
            System.out.println(Arrays.toString(temps));

            // БИНАРНЫЙ ПОИСК
            // temps - ссылка на массив, в котором ищем
            // 98,1 - искомое значение
            // если найдет, то вернет индекс в массиве
            // для быстрой и корректной работы метода массив дб отсортирован
            System.out.println(Arrays.binarySearch(temps, 98.1)); // 4
            System.out.println(Arrays.binarySearch(temps, 34)); // вернется индекс, который мог бы быть у этого числа

            // СОЗДАНИЕ КОПИЙ
            // 1) Позволяет сделать полную копию массива
            double[] newTemps01 = temps.clone(); // clone создает новый массив с таким же набором значений как в исходном
            System.out.println(Arrays.toString(newTemps01));

            // 2) Позволяет скопировать несколько первых элементов массива или сделать полную копию массива
            double[] newTemps02 = Arrays.copyOf(temps, 3); // 3 - число элементов, копируемых в новый массив
            System.out.println(Arrays.toString(newTemps02));

            // 3) System.arraycopy(Object src, int srcPos, Object dst, int dstPos, int len)
            // Метод копирует len элементов массива src, начиная с позиции srcPos,
            // в массив dst, начиная с позиции dstPos.
            // Массив dst должен иметь достаточный размер, чтобы в нем поместились все копируемые элементы.
            double[] newTemps03 = new double[30];
            System.arraycopy(temps, 0, newTemps03, 10, temps.length);
            System.out.println(Arrays.toString(newTemps03));

            //многомерные массиы - элемент массива другой массив
            // [][] - кол-во уровней вложенности массивов
            // {} - 1 -й уровень массива
            // {} - 2 -й уровень массива
            // приставка deep - метод работает с многомерным массивом
        }
    }
}
