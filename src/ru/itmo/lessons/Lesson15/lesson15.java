package ru.itmo.lessons.Lesson15;

// в коллекциях и массивах можно хранить только значения
// в map хранятся пары (ключ+связанное с ключом значение)
// ключи всегда будут уникальными (дублироваться ключи не могут)
// если добавить ключ, который уже есть, то старое значение удалится и запишется новое значение
// значения могут повторяться, быть любыми
// для ключей всегда дб переопределены equals и хэшкод
// реализация отличиается
// ключи могут хранится на основе хэшкода, в отсортированном порядке, быть слабыми ссылками
// в однопоточных средах популярен хэшмап
// мэп - дженерик тип
// тип данных ключей, тип данных значения
// можем добавлять пары, удалять пары по ключу и значению, делать замены, проверять наличие ключа или значения,
// очистить хранилище и т.д.
// удалить - значит удалить пару, а не только ключ или значение
// к одному ключу можно привязать только 1 значение (несколько быть не может)

import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

// метод добавления пары V put
// метод добавления несколько пар в существующий мэп Void putAll
// метод замены replace
// метод удаления пары по ключу
// метод удаления пары по ключу и значению
// получение значения по ключу (если ключа нет, то получим значение по умолчанию, которое сами укажем)
// получение значения по ключу (если ключа нет, то получим значение по умолчанию)
// метод проверки наличия ключа
// метод проверки наличия значения
// метод получения коллекции значения, т.к. значения могут повторяться, поэтому использование ключей в виде множества

// map - интерфейс
// пары хранятся в отсортированном по ключам порядке TreeMap
// слабые ссылки WeakHashMap
// HashMap
// EnupMap

// Экземпляры классов можно создать пустыми или на основе других мэп
public class lesson15 {

    // рассмотрим методы для map
    public static void main(String[] args) {

        // хранит ключи в hash-таблицу (использует hashCode() ключей для размещения элементов
        HashMap<String, Integer> customers = new HashMap<>(); // можем передать наследников // ключи - строки, значения - целые числа
        customers.put("Moscow", 790); // добавление пары
        customers.put("Rostov", 240); // добавление пары
        customers.put("Great Novgorod", 20); // добавление пары
        customers.put(null, null); // можем добавить null в качестве ключа, будет хранится самый первый, т.к. по хэшкоду null самый первый
        customers.put("Rostov", 300); // значение будет перезаписано
        customers.put("Samara", 560); // добавление пары

        System.out.println(customers.size());// всего будет добавлено 5 пар // учитывается только факт добавления и удаления

        // если ключа нет, то пара удалена не будет
        // если пары с null нет, то метод все равно вернет null
        // поэтому по использованию данного метода нельзя судить есть ключ с null в хранилище есть или нет
        // для наличия ключа в хранилище используем метод containsKey, другие методы не подходят
        customers.remove(null); // удалить можем по ключу // возвращает null - ссылку на удаленное значение (до замены) или null, если ключа в хранилище не будет
        // если реализации, которые разрешают использовать null в качестве ключа и метод отработает
        // если реализации, которые не разрешают использовать null в качестве ключа, то можем попаст на NullPointerException
        customers.put("Rostov", 300); // указанному ключу должно соответствовать указанное значение // возвращает True
        customers.put("Moscow", 300); // удаления не будет, т.к. нет такого значения для указанного // возвращает False
        System.out.println(customers.size()); // останется 3 пары

        // замены
        customers.replace("Moscow", 800); // заменит значение по ключу // возвращает ссылку на старое значение
        customers.replace("Great Novgorod", 20, 18); // заменит значение по ключу и значению // возвращает true (замена удачна) или false
        // значение будет заменено, т.к. ключ содержится

        // get - возвращает ссылку на значение
        // если ключ не найден, то вернет null
        System.out.println(customers.get("Moscow")); // 800
        System.out.println(customers.get("Rostov")); // null

        // если ключ не найден, то вернет значение по умолчанию, которое зададим
        System.out.println(customers.getOrDefault("Moscow", -1)); // 800
        System.out.println(customers.getOrDefault("Rostov", -1)); // -1

        // метод наличие ключа в хранилище
        // возвращает true false
        if (customers.containsKey("Saint-Petersubrg")) {
            System.out.println("Информация о городе содержится в map");
        }

        // метод наличие значения в хранилище
        // возвращает true false
        if (customers.containsValue(1000)) {
            System.out.println("В map есть значение 1000");
        }

        // TreeMap имеет такие методы как и HashMap
        TreeMap<String, Integer> sortedCustomers = new TreeMap<>(customers);
        // пары будут храниться в отсортированном по городам порядке
        // добавить пары в TreeMap удалось, т.к. класс String (тип данных ключей) реализует (
        // в классе String реализован его абстрактный метод compareTo, который определяет наименьший
        System.out.println();
        // sortedCustomers.put(null, null); ошибка, нельзя использовать null в качестве ключей
        // sortedCustomers.get(null, null); ошибка, ключи не могут быть null

        // EnumMap - Map, который хранит в качестве ключей перечисления
        // ключи не хранит, есть только массив со значениями
        // самая быстрая
        EnumMap<AppRole, String> enumMap = new EnumMap<AppRole, String>(AppRole.class); // тип данных на перечисление.класс - ссылка на класс
        // методы такие же как у TreeMap и HashMap

        //
        for (String key : sortedCustomers.keySet()) { // тип данных ключа String, переменная key: что перебираем (перебор множества ключей) sortedCustomers.keySet()
            // доступны методы типа данных
            System.out.println("ключ" + key);
        }

        for (Integer integer : sortedCustomers.values()) { // перебор значений
            System.out.println("значение" + integer);
        }

        // Map.Entry<> - тип данных пары
        // мы получаем множество set таких объектов
        // пары-объекты
        // перебор пар map

        for (Map.Entry<String, Integer> pair : customers.entrySet()) {
            if (pair.getValue() > 500) System.out.println(pair.getKey());
            // pair.getValue() - ассоциированное с ним значение
            // pair.getKey() - ключ
        }
    }
    public enum AppRole {
        USER, ADMIN,
    }
}
