package lesson04;
public class Lesson04 {
    public static void main(String[] args) {

        // char - примитивный тип данных 16 бит - символ Unicode
        char char01 = 'J'; // значение char записывается в одинарнах кавычках '..'
        char char02 = 74; // char может записан и по номеру, т.к. каждый символ имеет номер
        // согласно таблице Unicode в диапазоне от 0 до 65535
        // отрицательных номеров у символов нет
        char char03 = '\u0044'; // 16-ричное представление в escape последовательности,
        // которое также определяется таблицой Unicode;

        System.out.print(char01); // print не дает перенос строки в терминале
        System.out.println(char02); // добавляет символ переноса строки, но в коде его не видно
        System.out.println(char03);

        System.out.println('\uD83D' + '\uDC38');
        System.out.println('\uD83D'); // по отдельности смы
        System.out.println('\uDC38');
        System.out.println("\uD83D\uDC38" /* \n */); // суррогатная пара
        // каждый символ Unicode может быть представлен одним char либо парой
        // если символ Unicode представлен парой char, то это суррогатная пара (смайлики)

        // Строка - упорядоченная последовательность символов в "(символы)" кавычках
        // Строка - ссылочный тип, примитивных строк в Java нет
        // Строка - экземляр класса String (строки создаются и хранятся на основе правил класса String)
        // Создание строк:
        // 1. Можно создать строку в "...";
        // 2. через конструктор new String() - используется только, если первый вариант невозможен
        // в программу приходят байты. С помощью второго варианта
        // с указанием кодировки можно получить из байтов строку на выходе
        // Строки в языке неизмены, можно создать новую строку на основе существующей
        // "строка" -> "СТРОКА" -> "Строка" (в памяти будут хранится все 3 строки),
        // но сможем обратиться только к последней, если ранее было переопределение
        // Хранение строк до java 9: массив char в кодировке UTF-16, где каждый char был представлен 2-мя байтами
        // Хранение строк до java 9: массив byte в кодировке UTF-16 (2 байта) или LATIN-1 (1 байт)
        //['j', 'j', 'd'] для хранения одного латинского символа расходуется 2 байта, но символ занимает только 1 байт
        //['к', 'о', 'д']

        String string01 = "Строка"; // в пуле
        String string02 = "Строка"; // в пуле, string01 и string02 один объект с двумя ссылками
        String string03 = new String("Строка"); // в куче
        // original - подсказка среды, ставится автоматически, ее можно

        // ссылочные типы хранятся в heap (куча) памяти
        // в heap (куча) памяти находится пул строк

        System.out.println(string01 == string02); // true, если 2 переменные ссылаются на одну область памяти
        System.out.println(string01 == string03); // false, если 2 переменные ссылаются на разные области памяти

        // ссылочные типы не сравниваются через ==, т.к. сравниваются не значения,
        // а ссылки (переменные ведут к одному объекту памями или разным)

        string02 = null; // ссылка никуда не ведет, раньше string02 ссылалась на "Строка" в пуле,
        // а теперь она на него не ссылается, но объект из памяти при этом не пропадает
        // даже, если sting01 = null
        // для кучи это также актуально
        // объект исчезнет, если сборщик мусора определит, что ссылок на объект в памяти нет

        // оператор == можно использовать для ссылочных типов при использовании null
        System.out.println(string02 == null);

        // интернирование строк - строка помещается (не перемещается, а создается ее копия) в пул строк
        String internString = string03.intern(); // строку из new String("Строка") нужно поместить в пул строку
        string03 = null;
        System.out.println(string01 == internString);

        // сравнение строк
        // метод .equals - сравнение строк с учетом регистра
        string01 = "Строка";
        string02 = "Строка";
        System.out.println(string01.equals(string02)); // если регистр разный, то строки тоже разные

        // метод .equalsIgnoreCase - сравнение строк без учета регистра
        string01 = "cтрока";
        string02 = "Строка";
        System.out.println(string01.equalsIgnoreCase(string02));

        // если метод возращает булевое значение, то его можно использовать в циклах или if
        if (string01.equals(string02)) {
            // в циклах или if
            System.out.println("Строки равны");
        } else {
            System.out.println("Строки равны");
        }

        string01 = "Строка";
        string02 = null; // у null нет методов, т.к. это отсутствие
        //        System.out.println(string02.equals(string01)); // java.lang.NullPointerException

        if (string02 != null) System.out.println(string02.equals(string01));

        // конкатенация строк
        string01 = "Java";
        string02 = "Python";
        // + эквивалентен созданию строки через конструктор,
        // если обращение к строкам происходит через переменные
        String concatString = string01 + " :: " + string02; // 2 объекта
        // при каждом использовании оператора + мы получаем новую строку
        System.out.println(concatString);
        String concatString1 = "Java" + " :: " + "Python"; // -> "Java :: Python", т.е. один объект
        System.out.println(concatString1);

        // concat эквивалентен созданию строки через конструктор, но другой синтаксис
        concatString = string01.concat("::").concat(string02);

        // в циклах нельзя использовать +, метод concat и другие методы,
        // которые приводят к созданию промежуточных объектов

        // для создания строк принято использовать StringBuilder или StringBuffer
        // для создание длинных строк принято исплоьзовать
        // StringBuilder - в однопоточных программах
        // или
        // StringBuffer - несколько потоков
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            // concatString += " ";
            sb.append(i).append(" "); // к пустой строчку добавляем значение переменной i, а затем "_"
        }
        concatString = sb.toString();

    }
}
